;****************** main.s ***************
; Program written by: Jason Juliette and Kris Li
; Date Created: 2/14/2017
; Last Modified: 2/12/2018
; Brief description of the program
;   The LED toggles at 8 Hz and a varying duty-cycle
;   Repeat the functionality from Lab3 but now we want you to 
;   insert debugging instruments which gather data (state and timing)
;   to verify that the system is functioning as expected.
; Hardware connections (External: One button and one LED)
;  PE1 is Button input  (1 means pressed, 0 means not pressed)
;  PE0 is LED output (1 activates external LED on protoboard)
;  PF2 is Blue LED on Launchpad used as a heartbeat
		;*******same idea aas lab 3 but we need to change the hardware slightly****** 
			;lab 3:
			 ;Hardware connections (External: One button and one LED)
				;  PE1 is Button input  (1 means pressed, 0 means not pressed)
				;  PE0 is LED output (1 activates external LED on protoboard)
				;  PF4 is builtin button SW1 on Launchpad (Internal) 
					;we won't need this 
			;I think its still the same type of resistor (pull down) 
		;**//**// doesnt mean same initalization
			
; You will only verify the variable duty-cycle feature of Lab 3 and not the "breathing" feature. 
		;breating feature was a a different duty cycle
		;therefore the checkng mechanism only needs to check 8Hz
		
;**** Instrumentation data to be gathered is as follows:
; After Button(PE1) press collect one state and time entry. 
	; we can keep the original code
		;i think it works with it
; After Buttin(PE1) release, collect 7 state and
; time entries on each change in state of the LED(PE0): 
; An entry is one 8-bit entry in the Data Buffer and one 
; 32-bit entry in the Time Buffer
;  The Data Buffer entry (byte) content has:
;    Lower nibble is state of LED (PE0)					
;    Higher nibble is state of Button (PE1)			
;  The Time Buffer entry (32-bit) has:
;    24-bit value of the SysTick's Current register (NVIC_ST_CURRENT_R)
; Note: The size of both buffers is 50 entries. Once you fill these
;       entries you should stop collecting data
; The heartbeat is an indicator of the running of the program. 
; On each iteration of the main loop of your program toggle the 
; LED to indicate that your code(system) is live (not stuck or dead).

GPIO_PORTE_DATA_R  EQU 0x400243FC
GPIO_PORTE_DIR_R   EQU 0x40024400
GPIO_PORTE_AFSEL_R EQU 0x40024420
GPIO_PORTE_DEN_R   EQU 0x4002451C

GPIO_PORTF_DATA_R  EQU 0x400253FC
GPIO_PORTF_DIR_R   EQU 0x40025400
GPIO_PORTF_AFSEL_R EQU 0x40025420
GPIO_PORTF_PUR_R   EQU 0x40025510
GPIO_PORTF_DEN_R   EQU 0x4002551C
SYSCTL_RCGCGPIO_R  EQU 0x400FE608
Value EQU 500000		;this is 20% duty cycle
MAX EQU 2500000			;this is 100% duty cycle

; RAM Area
           AREA    DATA, ALIGN=2
;-UUU-Declare  and allocate space for your Buffers 
;    and any variables (like pointers and counters) here

; ROM Area
       IMPORT  TExaS_Init
       IMPORT SysTick Init
;-UUU-Import routine(s) from other assembly files (like SysTick.s) here
       AREA    |.text|, CODE, READONLY, ALIGN=2
       THUMB
       EXPORT  Start

Start

 ; TExaS_Init sets bus clock at 80 MHz
      BL  TExaS_Init ; voltmeter, scope on PD3
 ;place your initializations here
  LDR R0, = SYSCTL_RCGCGPIO_R;	i need port e and f
 LDR R1,[R0];
 ORR R1,#0x30;
 STR R1,[R0];
 NOP;
 NOP;
 NOP;
 NOP;
 B INIT_PORTE
 B INIT_PORTF
 LDR R0, = GPIO_PORTE_DATA_R
 LDR R2, = GPIO_PORTF_DATA_R
 LDR R8, = MAX 
 LDR R9, = Value; value is the incremention, and also the starting point, 1/5 of max duty cycle
 MOV R1,R9 ;R1 starts at initial value
      CPSIE  I    ; TExaS voltmeter, scope runs on interrupts
	  B SysTick_Init  
loop  
							;///////R1 is input to occilate delay 
							;///////R2 (PORTF) and R0 (PORTE) hold data registers
							;///////R3 is to change data in ports/change the light 
							;///////R9 hold comparison or constants for addition values 
 LDR R3,[R0]				
 ;LDR R4,[R2]////AND R4,#0x10//CMP R4,#0//BEQ breathstart	
 ANDS R4,R3,#0x2			;checks PE1 value for 1 in bit 1
 BEQ OOF					; if zero (button not pressed) continue
 BIC R3,#0x1				; not then turn the light off
 STR R3,[R0]				;it'll insignificant if the button is slightly pressed
Hold
 LDR R3,[R0]			 	;load a renewed PORTE data register
 ANDS R4,R3,#0x2			;check bit 1, the button
 BNE Hold					;if 1, then it'll contiune the loop an have no light output
 CMP R8,R1					;compare count to max
 BNE Nope 					;if max is greater than R1, skip these next lines
 AND R1,#0					;reset R1 (will this actually make the duty cycle 0?)
 B OOF						;skip the addition
Nope					
 ADD R1,R9 					;duty cycle increases linearily
OOF
 BL Occilate				;
 B loop
      B    loop


Occilate				
;input R1
;AAPCS doesnt matter
 EOR R3,#0x1				; toggle the light, friendly
 STR R3,[R0]				; store R3 into Data register
 MOV R4,R1				;R4 = R1, the count; change R1 in code to change the duty cycle
 ADD R4,#1				;//////there will likely be the same error as in delay2, but when duty cycle is 0%
 
Delay
 SUBS R4,#1			;R1 is the counter
 BNE Delay  		;PE1 will adjust the value of R1
 
 EOR R3,#0x1				; toggle the light, friendly
 STR R3,[R0]				; store R3 into Data register
 SUB R4,R8,R1		;R4 = difference of R8, and R1 (the rest of the duty cycle)
 ADD R4,#1 			;///instead of doing the comparison for bug, add 1 to R4 each time. might change the stuff by a nanosecond but its simple
 
Delay2																
 SUBS R4,#1			;R1 is the counter
 BNE Delay2 		
 BX LR
 
 INIT_PORTE		;same as lab 3 
 LDR R0, = GPIO_PORTE_DIR_R;  port e PE0 equals an output(1) and PE1 equals an input(0)
 LDR R1,[R0];
 ORR R1,#0x1;
 BIC R1,#0x2;
 STR R1,[R0];
 LDR R0, = GPIO_PORTE_DEN_R ; enable PE0/1
 LDR R1,[R0];
 ORR R1,#0x3;
 STR R1,[R0];
 BX LR
 
 INIT_PORTF		;PF2 is blue LED and OUTPUT
 LDR R0, = GPIO_PORTF_DIR_R;  port f PF4 as input (0)
 MOV R1,#4;
 STR R1,[R0];
 LDR R0, = GPIO_PORTF_DEN_R ; enable PF4
 STR R1,[R0]
 BX LR
      ALIGN      ; make sure the end of this section is aligned
      END        ; end of file

